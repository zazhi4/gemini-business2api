import asyncio
import logging
import os
import time
import uuid
from dataclasses import dataclass, field
from datetime import datetime, timedelta, timezone
from typing import Any, Callable, Dict, List, Optional

from core.account import load_accounts_from_source
from core.base_task_service import BaseTask, BaseTaskService, TaskCancelledError, TaskStatus
from core.config import config
from core.duckmail_client import DuckMailClient
from core.gemini_automation import GeminiAutomation
from core.gemini_automation_uc import GeminiAutomationUC
from core.microsoft_mail_client import MicrosoftMailClient

logger = logging.getLogger("gemini.login")


@dataclass
class LoginTask(BaseTask):
    """ç™»å½•ä»»åŠ¡æ•°æ®ç±»"""
    account_ids: List[str] = field(default_factory=list)

    def to_dict(self) -> dict:
        """è½¬æ¢ä¸ºå­—å…¸"""
        base_dict = super().to_dict()
        base_dict["account_ids"] = self.account_ids
        return base_dict


class LoginService(BaseTaskService[LoginTask]):
    """ç™»å½•æœåŠ¡ç±»"""

    def __init__(
        self,
        multi_account_mgr,
        http_client,
        user_agent: str,
        account_failure_threshold: int,
        rate_limit_cooldown_seconds: int,
        session_cache_ttl_seconds: int,
        global_stats_provider: Callable[[], dict],
        set_multi_account_mgr: Optional[Callable[[Any], None]] = None,
    ) -> None:
        super().__init__(
            multi_account_mgr,
            http_client,
            user_agent,
            account_failure_threshold,
            rate_limit_cooldown_seconds,
            session_cache_ttl_seconds,
            global_stats_provider,
            set_multi_account_mgr,
            log_prefix="REFRESH",
        )
        self._is_polling = False

    async def start_login(self, account_ids: List[str]) -> LoginTask:
        """å¯åŠ¨ç™»å½•ä»»åŠ¡ï¼ˆæ”¯æŒæŽ’é˜Ÿï¼‰ã€‚"""
        async with self._lock:
            # åŽ»é‡ï¼šåŒä¸€æ‰¹è´¦å·çš„ pending/running ä»»åŠ¡ç›´æŽ¥å¤ç”¨
            normalized = list(account_ids or [])
            for existing in self._tasks.values():
                if (
                    isinstance(existing, LoginTask)
                    and existing.account_ids == normalized
                    and existing.status in (TaskStatus.PENDING, TaskStatus.RUNNING)
                ):
                    return existing

            task = LoginTask(id=str(uuid.uuid4()), account_ids=normalized)
            self._tasks[task.id] = task
            self._append_log(task, "info", f"login task queued ({len(task.account_ids)} accounts)")
            await self._enqueue_task(task)
            if self._current_task_id:
                current = self._tasks.get(self._current_task_id)
                if current and current.status == TaskStatus.RUNNING:
                    raise ValueError("å·²æœ‰åˆ·æ–°ä»»åŠ¡æ­£åœ¨è¿è¡Œä¸­")

            task = LoginTask(id=str(uuid.uuid4()), account_ids=account_ids)
            self._tasks[task.id] = task
            self._current_task_id = task.id
            self._append_log(task, "info", f"ðŸ“ åˆ›å»ºåˆ·æ–°ä»»åŠ¡ (è´¦å·æ•°é‡: {len(account_ids)})")
            asyncio.create_task(self._run_login_async(task))
            return task

    def _execute_task(self, task: LoginTask):
        return self._run_login_async(task)

    async def _run_login_async(self, task: LoginTask) -> None:
        """å¼‚æ­¥æ‰§è¡Œç™»å½•ä»»åŠ¡ï¼ˆæ”¯æŒå–æ¶ˆï¼‰ã€‚"""
        loop = asyncio.get_running_loop()
        self._append_log(task, "info", f"ðŸš€ åˆ·æ–°ä»»åŠ¡å·²å¯åŠ¨ (å…± {len(task.account_ids)} ä¸ªè´¦å·)")

        for account_id in task.account_ids:
            if task.cancel_requested:
                self._append_log(task, "warning", f"login task cancelled: {task.cancel_reason or 'cancelled'}")
                task.status = TaskStatus.CANCELLED
                task.finished_at = time.time()
                return
        for idx, account_id in enumerate(task.account_ids, 1):
            try:
                self._append_log(task, "info", f"ðŸ“Š è¿›åº¦: {idx}/{len(task.account_ids)}")
                self._append_log(task, "info", "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
                self._append_log(task, "info", f"ðŸ”„ å¼€å§‹åˆ·æ–°è´¦å·: {account_id}")
                self._append_log(task, "info", "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
                result = await loop.run_in_executor(self._executor, self._refresh_one, account_id, task)
            except TaskCancelledError:
                # çº¿ç¨‹ä¾§å·²è§¦å‘å–æ¶ˆï¼Œç›´æŽ¥ç»“æŸä»»åŠ¡
                task.status = TaskStatus.CANCELLED
                task.finished_at = time.time()
                return
            except Exception as exc:
                result = {"success": False, "email": account_id, "error": str(exc)}
            task.progress += 1
            task.results.append(result)

            if result.get("success"):
                task.success_count += 1
                self._append_log(task, "info", "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
                self._append_log(task, "info", f"ðŸŽ‰ åˆ·æ–°æˆåŠŸ: {account_id}")
                self._append_log(task, "info", "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
            else:
                task.fail_count += 1
                error = result.get('error', 'æœªçŸ¥é”™è¯¯')
                self._append_log(task, "error", "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
                self._append_log(task, "error", f"âŒ åˆ·æ–°å¤±è´¥: {account_id}")
                self._append_log(task, "error", f"âŒ å¤±è´¥åŽŸå› : {error}")
                self._append_log(task, "error", "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")

        if task.cancel_requested:
            task.status = TaskStatus.CANCELLED
        else:
            task.status = TaskStatus.SUCCESS if task.fail_count == 0 else TaskStatus.FAILED
        task.finished_at = time.time()
        self._append_log(task, "info", f"login task finished ({task.success_count}/{len(task.account_ids)})")
        self._current_task_id = None
        self._append_log(task, "info", f"ðŸ åˆ·æ–°ä»»åŠ¡å®Œæˆ (æˆåŠŸ: {task.success_count}, å¤±è´¥: {task.fail_count}, æ€»è®¡: {len(task.account_ids)})")

    def _refresh_one(self, account_id: str, task: LoginTask) -> dict:
        """åˆ·æ–°å•ä¸ªè´¦æˆ·"""
        accounts = load_accounts_from_source()
        account = next((acc for acc in accounts if acc.get("id") == account_id), None)
        if not account:
            return {"success": False, "email": account_id, "error": "è´¦å·ä¸å­˜åœ¨"}

        if account.get("disabled"):
            return {"success": False, "email": account_id, "error": "è´¦å·å·²ç¦ç”¨"}

        # èŽ·å–é‚®ä»¶æä¾›å•†
        mail_provider = (account.get("mail_provider") or "").lower()
        if not mail_provider:
            if account.get("mail_client_id") or account.get("mail_refresh_token"):
                mail_provider = "microsoft"
            else:
                mail_provider = "duckmail"

        # èŽ·å–é‚®ä»¶é…ç½®
        mail_password = account.get("mail_password") or account.get("email_password")
        mail_client_id = account.get("mail_client_id")
        mail_refresh_token = account.get("mail_refresh_token")
        mail_tenant = account.get("mail_tenant") or "consumers"

        def log_cb(level, message):
            self._append_log(task, level, f"[{account_id}] {message}")

        log_cb("info", f"ðŸ“§ é‚®ä»¶æä¾›å•†: {mail_provider}")

        # åˆ›å»ºé‚®ä»¶å®¢æˆ·ç«¯
        if mail_provider == "microsoft":
            if not mail_client_id or not mail_refresh_token:
                return {"success": False, "email": account_id, "error": "Microsoft OAuth é…ç½®ç¼ºå¤±"}
            mail_address = account.get("mail_address") or account_id
            client = MicrosoftMailClient(
                client_id=mail_client_id,
                refresh_token=mail_refresh_token,
                tenant=mail_tenant,
                proxy=config.basic.proxy_for_auth,
                log_callback=log_cb,
            )
            client.set_credentials(mail_address)
        elif mail_provider == "duckmail":
            if not mail_password:
                return {"success": False, "email": account_id, "error": "é‚®ç®±å¯†ç ç¼ºå¤±"}
            # DuckMail: account_id å°±æ˜¯é‚®ç®±åœ°å€
            client = DuckMailClient(
                base_url=config.basic.duckmail_base_url,
                proxy=config.basic.proxy_for_auth,
                verify_ssl=config.basic.duckmail_verify_ssl,
                api_key=config.basic.duckmail_api_key,
                log_callback=log_cb,
            )
            client.set_credentials(account_id, mail_password)
        else:
            return {"success": False, "email": account_id, "error": f"ä¸æ”¯æŒçš„é‚®ä»¶æä¾›å•†: {mail_provider}"}

        # æ ¹æ®é…ç½®é€‰æ‹©æµè§ˆå™¨å¼•æ“Ž
        browser_engine = (config.basic.browser_engine or "dp").lower()
        headless = config.basic.browser_headless

        log_cb("info", f"ðŸŒ å¯åŠ¨æµè§ˆå™¨ (å¼•æ“Ž={browser_engine}, æ— å¤´æ¨¡å¼={headless})...")

        if browser_engine == "dp":
            # DrissionPage å¼•æ“Žï¼šæ”¯æŒæœ‰å¤´å’Œæ— å¤´æ¨¡å¼
            automation = GeminiAutomation(
                user_agent=self.user_agent,
                proxy=config.basic.proxy_for_auth,
                headless=headless,
                log_callback=log_cb,
            )
        else:
            # undetected-chromedriver å¼•æ“Žï¼šæ— å¤´æ¨¡å¼åæ£€æµ‹èƒ½åŠ›å¼±ï¼Œå¼ºåˆ¶ä½¿ç”¨æœ‰å¤´æ¨¡å¼
            if headless:
                log_cb("warning", "âš ï¸ UC å¼•æ“Žæ— å¤´æ¨¡å¼åæ£€æµ‹èƒ½åŠ›å¼±ï¼Œå¼ºåˆ¶ä½¿ç”¨æœ‰å¤´æ¨¡å¼")
                headless = False
            automation = GeminiAutomationUC(
                user_agent=self.user_agent,
                proxy=config.basic.proxy_for_auth,
                headless=headless,
                log_callback=log_cb,
            )
        # å…è®¸å¤–éƒ¨å–æ¶ˆæ—¶ç«‹åˆ»å…³é—­æµè§ˆå™¨
        self._add_cancel_hook(task.id, lambda: getattr(automation, "stop", lambda: None)())
        try:
            log_cb("info", "ðŸ” æ‰§è¡Œ Gemini è‡ªåŠ¨ç™»å½•...")
            result = automation.login_and_extract(account_id, client)
        except Exception as exc:
            log_cb("error", f"âŒ è‡ªåŠ¨ç™»å½•å¼‚å¸¸: {exc}")
            return {"success": False, "email": account_id, "error": str(exc)}
        if not result.get("success"):
            error = result.get("error", "è‡ªåŠ¨åŒ–æµç¨‹å¤±è´¥")
            log_cb("error", f"âŒ è‡ªåŠ¨ç™»å½•å¤±è´¥: {error}")
            return {"success": False, "email": account_id, "error": error}

        log_cb("info", "âœ… Gemini ç™»å½•æˆåŠŸï¼Œæ­£åœ¨ä¿å­˜é…ç½®...")

        # æ›´æ–°è´¦æˆ·é…ç½®
        config_data = result["config"]
        config_data["mail_provider"] = mail_provider
        config_data["mail_password"] = mail_password
        if mail_provider == "microsoft":
            config_data["mail_address"] = account.get("mail_address") or account_id
            config_data["mail_client_id"] = mail_client_id
            config_data["mail_refresh_token"] = mail_refresh_token
            config_data["mail_tenant"] = mail_tenant
        config_data["disabled"] = account.get("disabled", False)

        for acc in accounts:
            if acc.get("id") == account_id:
                acc.update(config_data)
                break

        self._apply_accounts_update(accounts)
        log_cb("info", "âœ… é…ç½®å·²ä¿å­˜åˆ°æ•°æ®åº“")
        return {"success": True, "email": account_id, "config": config_data}


    def _get_expiring_accounts(self) -> List[str]:
        accounts = load_accounts_from_source()
        expiring = []
        beijing_tz = timezone(timedelta(hours=8))
        now = datetime.now(beijing_tz)

        for account in accounts:
            if account.get("disabled"):
                continue
            mail_provider = (account.get("mail_provider") or "").lower()
            if not mail_provider:
                if account.get("mail_client_id") or account.get("mail_refresh_token"):
                    mail_provider = "microsoft"
                else:
                    mail_provider = "duckmail"

            mail_password = account.get("mail_password") or account.get("email_password")
            if mail_provider == "microsoft":
                if not account.get("mail_client_id") or not account.get("mail_refresh_token"):
                    continue
            else:
                if not mail_password:
                    continue
            expires_at = account.get("expires_at")
            if not expires_at:
                continue

            try:
                expire_time = datetime.strptime(expires_at, "%Y-%m-%d %H:%M:%S")
                expire_time = expire_time.replace(tzinfo=beijing_tz)
                remaining = (expire_time - now).total_seconds() / 3600
            except Exception:
                continue

            if remaining <= config.basic.refresh_window_hours:
                expiring.append(account.get("id"))

        return expiring

    async def check_and_refresh(self) -> Optional[LoginTask]:
        if os.environ.get("ACCOUNTS_CONFIG"):
            logger.info("[LOGIN] ACCOUNTS_CONFIG set, skipping refresh")
            return None
        expiring_accounts = self._get_expiring_accounts()
        if not expiring_accounts:
            logger.debug("[LOGIN] no accounts need refresh")
            return None

        try:
            return await self.start_login(expiring_accounts)
        except Exception as exc:
            logger.warning("[LOGIN] refresh enqueue failed: %s", exc)
            return None

    async def start_polling(self) -> None:
        if self._is_polling:
            logger.warning("[LOGIN] polling already running")
            return

        self._is_polling = True
        logger.info("[LOGIN] refresh polling started (interval: 30 minutes)")
        try:
            while self._is_polling:
                await self.check_and_refresh()
                await asyncio.sleep(1800)
        except asyncio.CancelledError:
            logger.info("[LOGIN] polling stopped")
        except Exception as exc:
            logger.error("[LOGIN] polling error: %s", exc)
        finally:
            self._is_polling = False

    def stop_polling(self) -> None:
        self._is_polling = False
        logger.info("[LOGIN] stopping polling")
